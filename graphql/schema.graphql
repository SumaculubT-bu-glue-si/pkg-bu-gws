"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime
  @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A date string with format `Y-m-d`, e.g. `2018-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"Response type for Google Workspace user list query"
type GoogleWorkspaceUserResponse {
  "List of users from Google Workspace"
  users: [GoogleWorkspaceUser!]!

  "Token for getting the next page of results"
  nextPageToken: String

  "Total number of items in the current response"
  totalItems: Int!
}

"Represents a user in Google Workspace"
type GoogleWorkspaceUser {
  "Unique identifier for the user"
  id: ID!

  "Primary email address of the user"
  primaryEmail: String!

  "User's full name information"
  name: GoogleWorkspaceUserName!

  "Whether the user is a super admin"
  isAdmin: Boolean!

  "Whether the user is a delegated admin"
  isDelegatedAdmin: Boolean!

  "Last login time of the user"
  lastLoginTime: String

  "Creation time of the user account"
  creationTime: String!

  "Whether the user account is suspended"
  suspended: Boolean!

  "Whether the user must change password at next login"
  changePasswordAtNextLogin: Boolean!

  "Path of the organizational unit the user belongs to"
  orgUnitPath: String!
}

"Name information for a Google Workspace user"
type GoogleWorkspaceUserName {
  "Given (first) name"
  givenName: String!

  "Family (last) name"
  familyName: String!

  "Full name (givenName + familyName)"
  fullName: String!
}

"Indicates what fields are available at the top level of a query operation."
type Query {
  # Google Workspace queries
  "List users from Google Workspace"
  googleWorkspaceUsers(
    "Domain name (e.g., capo.co.jp)"
    domain: String!

    "Maximum number of results to return"
    maxResults: Int = 100

    "Token for getting the next page of results"
    pageToken: String

    "Search query to filter users"
    query: String

    "Organization unit path to filter users"
    orgUnitPath: String

    "Timestamp in RFC 3339 format to list users modified after this time"
    updatedMin: String
  ): GoogleWorkspaceUserResponse!
    @field(
      resolver: "Bu\\Gws\\GraphQL\\Queries\\GoogleWorkspaceQueries@listUsers"
    )

  # User queries
  "Find a single user by an identifying attribute."
  user(
    "Search by primary key."
    id: ID @eq @rules(apply: ["prohibits:email", "required_without:email"])

    "Search by email address."
    email: String
      @eq
      @rules(apply: ["prohibits:id", "required_without:id", "email"])
  ): User @find

  "List multiple users."
  users(
    "Filters by name. Accepts SQL LIKE wildcards `%` and `_`."
    name: String @where(operator: "like")
  ): [User!]! @paginate(defaultCount: 10)

  # Asset queries
  "Find a single asset by ID."
  asset(id: ID! @eq): Asset @find

  "List multiple assets with optional filtering."
  assets(
    "Exact match asset type (pc, monitor, smartphones, others)."
    type: String

    "Exclude asset types (for 'others' category)."
    exclude_types: [String!]

    "Filter by multiple statuses."
    statuses: [String!]

    "Filter by multiple locations."
    locations: [String!]

    "Filter by assigned user ID (employee id)."
    user_id: ID

    "Filter by employee name (partial match) via relation."
    employee_name: String

    "Field-specific filters (partial match)."
    asset_id: String
    hostname: String
    manufacturer: String
    model: String
    part_number: String
    serial_number: String
    form_factor: String
    os: String
    os_bit: String
    office_suite: String
    software_license_key: String
    wired_mac_address: String
    wired_ip_address: String
    wireless_mac_address: String
    wireless_ip_address: String
    previous_user: String
    project: String
    notes: String
    notes1: String
    notes2: String
    notes3: String
    notes4: String
    notes5: String
    cpu: String
    memory: String

    "Global search across common textual columns (partial match)."
    global: String

    "Pagination: page size and page number."
    first: Int
    page: Int

    "Sorting: database column name in snake_case and direction."
    sort_field: String
    sort_direction: String
  ): [Asset!]!
    @paginate(
      defaultCount: 100
      builder: "Bu\\Server\\GraphQL\\Queries\\AssetQueries@assetsBuilder"
    )

  # Employee queries
  "Find a single employee by ID."
  employee(id: ID! @eq): Employee @find

  "List multiple employees with optional filtering."
  employees(name: String @where(operator: "like")): [Employee!]!
    @paginate(defaultCount: 20)

  # Project queries
  "Find a single project by ID."
  project(id: ID! @eq): Project @find

  "List multiple projects with optional filtering."
  projects(name: String @where(operator: "like")): [Project!]!
    @paginate(defaultCount: 20)

  # Location queries
  "Find a single location by ID."
  location(id: ID! @eq): Location
    @field(resolver: "Bu\\Server\\GraphQL\\Queries\\LocationQueries@location")

  "List multiple locations with optional filtering."
  locations(
    name: String @where(operator: "like")
    status: String @where(operator: "=")
    city: String @where(operator: "like")
  ): [Location!]!
    @field(resolver: "Bu\\Server\\GraphQL\\Queries\\LocationQueries@locations")

  # Audit queries
  "Find a single audit plan by ID."
  auditPlan(id: ID! @eq): AuditPlan @find

  "List multiple audit plans with optional filtering."
  auditPlans(
    status: String @where(operator: "=")
    created_by: ID @where(operator: "=")
  ): [AuditPlan!]! @paginate(defaultCount: 20)

  "Find audit assets for a specific audit plan."
  auditAssets(
    audit_plan_id: ID! @where(operator: "=")
    current_status: String @where(operator: "=")
  ): [AuditAsset!]! @paginate(defaultCount: 50)

  "Find audit assignments for a specific audit plan."
  auditAssignments(
    audit_plan_id: ID! @where(operator: "=")
    auditor_id: ID @where(operator: "=")
  ): [AuditAssignment!]! @paginate(defaultCount: 20)

  # Corrective Action queries
  "Find corrective actions for a specific audit plan."
  correctiveActions(
    audit_plan_id: ID @where(operator: "=")
    status: String @where(operator: "=")
    priority: String @where(operator: "=")
    assigned_to: String @where(operator: "like")
  ): [CorrectiveAction!]! @paginate(defaultCount: 50)

  "Find a single corrective action by ID."
  correctiveAction(id: ID! @eq): CorrectiveAction @find

  # Employee Audit queries
  "Get available audit plans for employee selection."
  availableAuditPlans: [AvailableAuditPlan!]!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Queries\\EmployeeAuditQueries@getAvailableAuditPlans"
    )

  "Get employee audit access data using access token."
  employeeAuditAccess(
    token: String! @rules(apply: ["required"])
  ): EmployeeAuditAccessData!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Queries\\EmployeeAuditQueries@getEmployeeAuditAccess"
    )

  "Get corrective actions for an employee in an audit plan."
  employeeCorrectiveActions(
    employee_id: ID! @rules(apply: ["required"])
    audit_plan_id: ID! @rules(apply: ["required"])
  ): CorrectiveActionsResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Queries\\EmployeeAuditQueries@getCorrectiveActions"
    )

  "Get audit assets for a specific audit plan using access token."
  auditPlanAssets(
    token: String! @rules(apply: ["required"])
    planId: ID! @rules(apply: ["required"])
  ): AuditPlanAssetsResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Queries\\EmployeeAuditQueries@getAuditPlanAssets"
    )

  "Get audit history for an employee using access token."
  auditHistory(
    token: String! @rules(apply: ["required"])
  ): AuditHistoryResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Queries\\EmployeeAuditQueries@getAuditHistory"
    )

  "Get detailed information about a specific audit asset."
  auditAssetDetails(
    auditAssetId: ID! @rules(apply: ["required"])
  ): AuditAssetDetailsResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Queries\\EmployeeAuditQueries@getAuditAssetDetails"
    )
}

"Account of a person who uses this application."
type User {
  "Unique primary key."
  id: ID!

  "Non-unique name."
  name: String!

  "Unique email address."
  email: String!

  "When the email was verified."
  email_verified_at: DateTime

  "When the account was created."
  created_at: DateTime!

  "When the account was last updated."
  updated_at: DateTime!
}

"Asset in the inventory system."
type Asset {
  "Unique primary key."
  id: ID!

  "Asset ID (PC001, PC002, etc.)."
  asset_id: String!

  "Type of asset (pc, monitor, phone)."
  type: String!

  "Hostname of the asset."
  hostname: String

  "Manufacturer of the asset."
  manufacturer: String

  "Model of the asset."
  model: String

  "Part number."
  part_number: String

  "Unique serial number."
  serial_number: String

  "Form factor (Laptop, Desktop, etc.)."
  form_factor: String

  "Operating system."
  os: String

  "OS bit version."
  os_bit: String

  "Office suite installed."
  office_suite: String

  "Software license key."
  software_license_key: String

  "Wired MAC address."
  wired_mac_address: String

  "Wired IP address."
  wired_ip_address: String

  "Wireless MAC address."
  wireless_mac_address: String

  "Wireless IP address."
  wireless_ip_address: String

  "Date when the asset was purchased."
  purchase_date: Date

  "Purchase price."
  purchase_price: Float

  "Purchase price including tax."
  purchase_price_tax_included: Float

  "Depreciation years."
  depreciation_years: Int

  "Depreciation department."
  depreciation_dept: String

  "CPU specification."
  cpu: String

  "Memory specification."
  memory: String

  "Location where the asset is stored."
  location: String

  "Current status of the asset."
  status: String

  "Previous user of the asset."
  previous_user: String

  "Current user assigned to this asset."
  user_id: ID

  "Employee assigned to this asset."
  employee: Employee
    @field(resolver: "Bu\\Server\\GraphQL\\Queries\\AssetQueries@employee")

  "Date when usage started."
  usage_start_date: Date

  "Date when usage ended."
  usage_end_date: Date

  "Carry in/out agreement status."
  carry_in_out_agreement: String

  "Last updated timestamp."
  last_updated: DateTime

  "Updated by user."
  updated_by: String

  "Additional notes about the asset."
  notes: String

  "Project associated with the asset."
  project: String

  "Additional notes fields."
  notes1: String
  notes2: String
  notes3: String
  notes4: String
  notes5: String

  "When the asset was created."
  created_at: DateTime!

  "When the asset was last updated."
  updated_at: DateTime!
}

"Employee in the system."
type Employee {
  "Unique primary key."
  id: ID!

  "Unique employee ID (from Google Workspace)."
  employee_id: String!

  "Full name of the employee."
  name: String!

  "Email address of the employee."
  email: String

  "Location/branch of the employee."
  location: String

  "Organizational unit path in Google Workspace."
  org_unit_path: String

  "Projects assigned to the employee."
  projects: [String!]

  "When the employee record was created."
  created_at: DateTime!

  "When the employee record was last updated."
  updated_at: DateTime!
}

"Location in the system."
type Location {
  "Unique primary key."
  id: ID!

  "Name of the location."
  name: String!

  "Address of the location."
  address: String

  "City of the location."
  city: String

  "State/province of the location."
  state: String

  "Country of the location."
  country: String

  "Postal code of the location."
  postal_code: String

  "Phone number of the location."
  phone: String

  "Email of the location."
  email: String

  "Manager of the location."
  manager: String

  "Status of the location."
  status: String

  "Whether the location is visible."
  visible: Boolean!

  "Order of the location for display."
  order: Int!

  "When the location was created."
  created_at: DateTime!

  "When the location was last updated."
  updated_at: DateTime!
}

"Project in the system."
type Project {
  "Unique primary key."
  id: ID!

  "Name of the project."
  name: String!

  "Description of the project."
  description: String

  "Whether the project is visible."
  visible: Boolean!

  "Order of the project for sorting."
  order: Int!

  "When the project was created."
  created_at: DateTime!

  "When the project was last updated."
  updated_at: DateTime!
}

"Input for creating or updating an asset. Uses the same snake_case field names as the Asset type."
input AssetInput {
  asset_id: String!
  type: String
  hostname: String
  manufacturer: String
  model: String
  part_number: String
  serial_number: String
  form_factor: String
  os: String
  os_bit: String
  office_suite: String
  software_license_key: String
  wired_mac_address: String
  wired_ip_address: String
  wireless_mac_address: String
  wireless_ip_address: String
  purchase_date: Date
  purchase_price: Float
  purchase_price_tax_included: Float
  depreciation_years: Int
  depreciation_dept: String
  cpu: String
  memory: String
  location: String
  status: String
  previous_user: String
  user: String
  user_id: ID
  usage_start_date: Date
  usage_end_date: Date
  carry_in_out_agreement: String
  last_updated: DateTime
  updated_by: String
  notes: String
  project: String
  notes1: String
  notes2: String
  notes3: String
  notes4: String
  notes5: String
}

"Input for creating or updating an employee."
input EmployeeInput {
  employee_id: String!
  name: String!
  email: String
  location: String
  projects: [String!]
}

"Input for creating or updating a project."
input ProjectInput {
  name: String!
  description: String
  visible: Boolean
  order: Int
}

"Input for creating or updating a location."
input LocationInput {
  name: String!
  address: String
  city: String
  state: String
  country: String
  postal_code: String
  phone: String
  email: String
  manager: String
  status: String
  visible: Boolean
  order: Int
}

"Input for creating or updating a user."
input UserInput {
  name: String!
  email: String! @rules(apply: ["email"])
  password: String
}

"Calendar event for audit plans."
type CalendarEvent {
  "Unique identifier for the calendar event."
  id: String!

  "Title of the calendar event."
  title: String!

  "When the event was created."
  created_at: String!

  "Number of attendees."
  attendees_count: Int!

  "Location of the event."
  location: String
}

"Audit plan in the system."
type AuditPlan {
  "Unique primary key."
  id: ID!

  "Name of the audit plan."
  name: String!

  "Start date of the audit."
  start_date: Date!

  "Due date for completing the audit."
  due_date: Date!

  "Current status of the audit plan."
  status: String!

  "User who created the audit plan."
  created_by: ID!

  "Description of the audit plan."
  description: String

  "Calendar events created for this audit plan."
  calendar_events: [CalendarEvent!]

  "Google Chat space ID for this audit plan."
  chat_space_id: String

  "Google Chat space name for this audit plan."
  chat_space_name: String

  "When the chat space was created."
  chat_space_created_at: DateTime

  "When the audit plan was created."
  created_at: DateTime!

  "When the audit plan was last updated."
  updated_at: DateTime!

  "Audit assignments for this plan."
  assignments: [AuditAssignment!]! @hasMany

  "Assets being audited in this plan."
  auditAssets: [AuditAsset!]! @hasMany

  "Progress percentage of the audit plan."
  progress: Int! @method

  "Whether the audit plan is overdue."
  is_overdue: Boolean! @method
}

"Audit assignment linking auditors to locations."
type AuditAssignment {
  "Unique primary key."
  id: ID!

  "Audit plan this assignment belongs to."
  audit_plan_id: ID!

  "Location assigned for this audit."
  location_id: ID!

  "Auditor assigned to this location."
  auditor_id: ID!

  "Status of the assignment."
  status: String!

  "Notes about the assignment."
  notes: String

  "When the assignment was made."
  assigned_at: DateTime!

  "When the assignment was created."
  created_at: DateTime!

  "When the assignment was last updated."
  updated_at: DateTime!

  "The audit plan for this assignment."
  audit_plan: AuditPlan! @belongsTo

  "The location for this assignment."
  location: Location! @belongsTo

  "The auditor for this assignment."
  auditor: Employee! @belongsTo
}

"Audit asset tracking individual assets in an audit."
type AuditAsset {
  "Unique primary key."
  id: ID!

  "Audit plan this asset belongs to."
  audit_plan_id: ID!

  "Asset being audited."
  asset_id: ID!

  "Original location when audit plan was created."
  original_location: String!

  "Original user when audit plan was created."
  original_user: String

  "Current status of the asset audit."
  current_status: String!

  "Notes from the auditor."
  auditor_notes: String

  "When the asset was audited."
  audited_at: DateTime

  "Whether issues were resolved."
  resolved: Boolean!

  "Whether the asset has been audited (audit progress tracking)."
  audit_status: Boolean!

  "Who audited this asset."
  audited_by: String

  "Current location if different from original."
  current_location: String

  "Current user if different from original."
  current_user: String

  "When the audit asset record was created."
  created_at: DateTime!

  "When the audit asset record was last updated."
  updated_at: DateTime!

  "The audit plan for this asset."
  audit_plan: AuditPlan! @belongsTo

  "The asset being audited."
  asset: Asset! @belongsTo

  "Whether the asset has been audited."
  is_audited: Boolean! @method

  "Whether the asset has issues."
  has_issues: Boolean! @method

  "Corrective actions for this audit asset."
  correctiveActions: [CorrectiveAction!]! @hasMany
}

"Corrective action to resolve audit findings."
type CorrectiveAction {
  "Unique primary key."
  id: ID!

  "Audit asset this action relates to."
  audit_asset_id: ID!

  "Audit plan this action belongs to."
  audit_plan_id: ID!

  "Description of the issue found."
  issue: String!

  "Action required to resolve the issue."
  action: String!

  "Person assigned to complete this action."
  assigned_to: String

  "Priority level of the action."
  priority: String!

  "Current status of the action."
  status: String!

  "Due date for completion."
  due_date: Date!

  "Date when action was completed."
  completed_date: Date

  "Additional notes about the action."
  notes: String

  "When the action was created."
  created_at: DateTime!

  "When the action was last updated."
  updated_at: DateTime!

  "The audit asset this action relates to."
  auditAsset: AuditAsset! @belongsTo

  "The audit plan this action belongs to."
  auditPlan: AuditPlan! @belongsTo

  "The assignment for this corrective action."
  assignment: CorrectiveActionAssignment @hasOne
}

"Assignment of a corrective action to an audit assignment."
type CorrectiveActionAssignment {
  "Unique primary key."
  id: ID!

  "Corrective action this assignment belongs to."
  corrective_action_id: ID!

  "Audit assignment this corrective action is linked to."
  audit_assignment_id: ID!

  "Employee assigned to complete this corrective action."
  assigned_to_employee_id: ID

  "Current status of the assignment."
  status: String!

  "When the assignment was made."
  assigned_at: DateTime!

  "When the assignment was started."
  started_at: DateTime

  "When the assignment was completed."
  completed_at: DateTime

  "Progress notes for this assignment."
  progress_notes: String

  "When the assignment was created."
  created_at: DateTime!

  "When the assignment was last updated."
  updated_at: DateTime!

  "The corrective action for this assignment."
  correctiveAction: CorrectiveAction! @belongsTo

  "The audit assignment this corrective action is linked to."
  auditAssignment: AuditAssignment! @belongsTo

  "The employee assigned to complete this corrective action."
  assignedToEmployee: Employee @belongsTo
}

"Available audit plan for employee selection with progress information."
type AvailableAuditPlan {
  "Unique primary key."
  id: ID!

  "Name of the audit plan."
  name: String!

  "Start date of the audit."
  start_date: Date!

  "Due date for completing the audit."
  due_date: Date!

  "Current status of the audit plan."
  status: String!

  "Progress information for this audit plan."
  progress: AuditPlanProgress!
}

"Progress information for an audit plan."
type AuditPlanProgress {
  "Total number of assets in the audit plan."
  total_assets: Int!

  "Number of assets that have been audited."
  audited_assets: Int!

  "Progress percentage (0-100)."
  percentage: Int!
}

"Response for audit access request."
type AuditAccessResponse {
  "Whether the request was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Whether the email was sent successfully."
  email_sent: Boolean

  "Access URL (fallback if email fails)."
  accessUrl: String

  "Token expiration time."
  expiresAt: String
}

"Employee audit access data response."
type EmployeeAuditAccessData {
  "Whether the access was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Employee information."
  employee: EmployeeInfo

  "Selected audit plan data."
  selectedPlan: AuditPlanData

  "Audit assets for the employee."
  auditAssets: [AuditAssetData!]!

  "Employee role and permissions."
  role: EmployeeRole!
}

"Employee information for audit access."
type EmployeeInfo {
  "Unique primary key."
  id: ID!

  "Employee name."
  name: String!

  "Employee email."
  email: String!
}

"Audit plan data for access."
type AuditPlanData {
  "Unique primary key."
  id: ID!

  "Name of the audit plan."
  name: String!

  "Start date of the audit."
  start_date: Date!

  "Due date for completing the audit."
  due_date: Date!

  "Progress percentage (0-100)."
  progress: Int!

  "Total number of assets in the audit plan."
  total_assets: Int!

  "Number of completed assets."
  completed_assets: Int!
}

"Audit asset data for employee access."
type AuditAssetData {
  "Unique primary key."
  id: ID!

  "Asset ID."
  asset_id: ID!

  "Asset type."
  asset_type: String!

  "Asset model."
  model: String!

  "Original user assigned to the asset."
  original_user: String!

  "Original location of the asset."
  original_location: String!

  "Current user assigned to the asset."
  current_user: String!

  "Current location of the asset."
  current_location: String!

  "Current status of the asset."
  status: String!

  "Whether the asset has been audited."
  audit_status: Boolean!

  "Auditor notes for the asset."
  notes: String

  "When the asset was audited."
  audited_at: DateTime

  "Whether the asset has been resolved."
  resolved: Boolean!
}

"Employee role and permissions for audit access."
type EmployeeRole {
  "Whether the employee is an auditor."
  isAuditor: Boolean!

  "Assigned location for auditors."
  assignedLocation: String

  "Whether the employee can audit all assets."
  canAuditAllAssets: Boolean!

  "Description of the employee's role."
  description: String!
}

"Response for corrective actions query."
type CorrectiveActionsResponse {
  "Whether the request was successful."
  success: Boolean!

  "Response message."
  message: String!

  "List of corrective actions."
  actions: [CorrectiveActionData!]!

  "Employee role information."
  role: CorrectiveActionRole!
}

"Corrective action data for employee access."
type CorrectiveActionData {
  "Unique primary key."
  id: ID!

  "Audit asset ID this action relates to."
  audit_asset_id: ID!

  "Description of the issue."
  issue: String!

  "Action to be taken."
  action: String!

  "Employee assigned to complete this action."
  assigned_to: ID!

  "Priority level of the action."
  priority: String!

  "Current status of the action."
  status: String!

  "Due date for completion."
  due_date: Date

  "Date when the action was completed."
  completed_date: Date

  "Additional notes."
  notes: String

  "When the action was created."
  created_at: DateTime!

  "When the action was last updated."
  updated_at: DateTime!

  "Asset information for this corrective action."
  asset: CorrectiveActionAsset!
}

"Asset information for corrective actions."
type CorrectiveActionAsset {
  "Asset ID."
  asset_id: String!

  "Asset model."
  model: String!

  "Asset location."
  location: String!
}

"Employee role information for corrective actions."
type CorrectiveActionRole {
  "Whether the employee is an auditor."
  isAuditor: Boolean!

  "Assigned location for auditors."
  assignedLocation: String

  "Whether the employee can see all actions."
  canSeeAllActions: Boolean!

  "Description of the employee's role."
  description: String!
}

"Response for updating corrective action status."
type CorrectiveActionStatusResponse {
  "Whether the update was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Updated corrective action data."
  action: CorrectiveActionData
}

"Response for updating asset status."
type AssetStatusResponse {
  "Whether the update was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Updated asset data."
  asset: AssetUpdateData

  "Whether the main asset was updated."
  main_asset_updated: Boolean!

  "User assignment information."
  user_assignment: UserAssignmentData

  "Changes detected in the asset."
  changes_detected: AssetChangesData!
}

"Asset update data for status updates."
type AssetUpdateData {
  "Audit asset ID."
  id: ID!

  "Whether the asset has been audited."
  audit_status: Boolean!

  "Current status of the asset."
  current_status: String!

  "Auditor notes."
  notes: String

  "When the asset was audited."
  audited_at: DateTime

  "Who audited the asset."
  audited_by: String

  "Whether the location has changed."
  location_changed: Boolean!

  "Whether the user has changed."
  user_changed: Boolean!

  "Whether a user was assigned."
  user_assigned: Boolean!
}

"User assignment data for asset updates."
type UserAssignmentData {
  "Previous user ID."
  old_user_id: ID

  "New user ID."
  new_user_id: ID

  "New user name."
  new_user_name: String
}

"Asset changes data for tracking modifications."
type AssetChangesData {
  "Whether the location changed."
  location: Boolean!

  "Whether the user changed."
  user: Boolean!
}

"Response for audit plan assets query."
type AuditPlanAssetsResponse {
  "Whether the request was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Audit plan information."
  auditPlan: AuditPlanInfo

  "List of audit assets."
  auditAssets: [AuditAssetInfo!]!

  "Progress information for the audit plan."
  progress: AuditProgressInfo!
}

"Audit plan information for assets query."
type AuditPlanInfo {
  "Unique primary key."
  id: ID!

  "Name of the audit plan."
  name: String!

  "Start date of the audit."
  start_date: Date!

  "Due date for completing the audit."
  due_date: Date!

  "Current status of the audit plan."
  status: String!
}

"Audit asset information for plan assets query."
type AuditAssetInfo {
  "Unique primary key."
  id: ID!

  "Asset ID."
  asset_id: ID!

  "Asset type."
  asset_type: String!

  "Asset model."
  model: String!

  "Original user assigned to the asset."
  original_user: String!

  "Original location of the asset."
  original_location: String!

  "Current user assigned to the asset."
  current_user: String!

  "Current location of the asset."
  current_location: String!

  "Current status of the asset."
  status: String!

  "Whether the asset has been audited."
  audit_status: Boolean!

  "Auditor notes for the asset."
  notes: String

  "When the asset was audited."
  audited_at: DateTime

  "Whether the asset has been resolved."
  resolved: Boolean!
}

"Audit progress information for plan assets query."
type AuditProgressInfo {
  "Total number of assets in the audit plan."
  total_assets: Int!

  "Number of assets that have been audited."
  audited_assets: Int!

  "Progress percentage (0-100)."
  percentage: Int!
}

"Response for audit history query."
type AuditHistoryResponse {
  "Whether the request was successful."
  success: Boolean!

  "Response message."
  message: String!

  "List of audited assets in chronological order."
  auditHistory: [AuditHistoryItem!]!
}

"Audit history item for tracking completed audits."
type AuditHistoryItem {
  "Unique primary key."
  id: ID!

  "Asset type."
  asset_type: String!

  "Asset model."
  model: String!

  "Current status of the asset."
  status: String!

  "Auditor notes for the asset."
  notes: String

  "When the asset was audited."
  audited_at: DateTime!

  "Name of the audit plan this asset belonged to."
  audit_plan_name: String!

  "Current location of the asset."
  location: String!

  "Current user of the asset."
  user: String!
}

"Response for audit asset details query."
type AuditAssetDetailsResponse {
  "Whether the request was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Detailed audit asset information."
  audit_asset: AuditAssetDetails
}

"Detailed audit asset information."
type AuditAssetDetails {
  "Unique primary key."
  id: ID!

  "Asset ID."
  asset_id: ID!

  "Asset type."
  asset_type: String!

  "Asset model."
  model: String!

  "Original location of the asset."
  original_location: String

  "Original user of the asset."
  original_user: String

  "Current status of the asset."
  current_status: String

  "Current location of the asset."
  current_location: String

  "Current user of the asset."
  current_user: String

  "Auditor notes for the asset."
  auditor_notes: String

  "When the asset was audited."
  audited_at: DateTime

  "Whether the asset has been resolved."
  resolved: Boolean!

  "Whether the asset has been audited."
  audit_status: Boolean!

  "Audit summary information."
  audit_summary: AuditSummary

  "Status transition history."
  status_history: [StatusHistoryItem!]!

  "Corrective actions for this asset."
  corrective_actions: [CorrectiveActionDetails!]!
}

"Audit summary information."
type AuditSummary {
  "Summary text of the audit."
  summary: String

  "Key findings from the audit."
  findings: [String!]!

  "Recommendations from the audit."
  recommendations: [String!]!
}

"Status history item for tracking changes."
type StatusHistoryItem {
  "Previous status."
  from_status: String

  "New status."
  to_status: String!

  "When the status changed."
  changed_at: DateTime!

  "Who changed the status."
  changed_by: String

  "Reason for the change."
  reason: String
}

"Corrective action details."
type CorrectiveActionDetails {
  "Unique primary key."
  id: ID!

  "Issue description."
  issue: String!

  "Action to be taken."
  action: String!

  "Priority level."
  priority: String!

  "Current status."
  status: String!

  "Due date for completion."
  due_date: Date

  "When it was completed."
  completed_date: Date

  "Additional notes."
  notes: String

  "Who it's assigned to."
  assigned_to: String
}

"Response for sending scheduled reminders."
type ScheduledRemindersResponse {
  "Whether the operation was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Number of reminders sent."
  reminders_sent: Int!

  "Number of corrective actions processed."
  actions_processed: Int!

  "Details about the reminder process."
  details: ReminderDetails
}

"Details about the reminder process."
type ReminderDetails {
  "Number of pending actions that received reminders."
  pending_reminders: Int!

  "Number of in-progress actions that received reminders."
  in_progress_reminders: Int!

  "Number of overdue actions that received reminders."
  overdue_reminders: Int!

  "List of employees who received reminders."
  employees_notified: [String!]!

  "Any errors that occurred during the process."
  errors: [String!]!
}

"Response for sending manual reminders."
type ManualRemindersResponse {
  "Whether the operation was successful."
  success: Boolean!

  "Response message."
  message: String!

  "Number of reminders sent."
  reminders_sent: Int!

  "Number of actions processed."
  actions_processed: Int!

  "Details about the reminder process."
  details: ManualReminderDetails
}

"Details about manual reminder process."
type ManualReminderDetails {
  "List of employees who received reminders."
  employees_notified: [String!]!

  "List of action IDs that were processed."
  actions_processed: [ID!]!

  "Any errors that occurred during the process."
  errors: [String!]!
}

"Input for creating or updating a corrective action."
input CorrectiveActionInput {
  "Audit asset ID this action relates to."
  audit_asset_id: ID!

  "Description of the issue found."
  issue: String!

  "Action required to resolve the issue."
  action: String!

  "Person assigned to complete this action."
  assigned_to: String

  "Priority level of the action."
  priority: String!

  "Due date for completion."
  due_date: Date!

  "Additional notes about the action."
  notes: String
}

"Indicates what fields are available at the top level of a mutation operation."
type Mutation {
  # User mutations
  "Create a new user."
  createUser(user: UserInput!): User!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UserMutations@create")

  "Update an existing user."
  updateUser(id: ID!, user: UserInput!): User!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UserMutations@update")

  "Delete a user."
  deleteUser(id: ID!): Boolean!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UserMutations@delete")

  # Asset mutations
  "Create or update a single asset by asset_id."
  upsertAsset(asset: AssetInput!): Asset
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\AssetMutations@upsertAsset"
    )

  "Create or update many assets by asset_id. Returns the upserted assets."
  bulkUpsertAssets(assets: [AssetInput!]!): [Asset!]!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\AssetMutations@bulkUpsertAssets"
    )

  "Delete an asset by asset_id. Returns true if deleted or did not exist."
  deleteAsset(asset_id: String!): Boolean!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\AssetMutations@deleteAsset"
    )

  # Employee mutations
  "Create a new employee."
  createEmployee(employee: EmployeeInput!): Employee!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@create")

  "Update an existing employee."
  updateEmployee(id: ID!, employee: EmployeeInput!): Employee!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@update")

  "Delete an employee."
  deleteEmployee(id: ID!): Boolean!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@delete")

  "Create or update an employee (upsert)."
  upsertEmployee(employee: EmployeeInput!): Employee!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@upsertEmployee"
    )

  "Create or update many employees (bulk upsert)."
  bulkUpsertEmployees(employees: [EmployeeInput!]!): [Employee!]!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@bulkUpsertEmployees"
    )

  # Project mutations
  "Create a new project."
  createProject(project: ProjectInput!): Project!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@create")

  "Update an existing project."
  updateProject(id: ID!, project: ProjectInput!): Project!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@update")

  "Delete a project."
  deleteProject(id: ID!): Boolean!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@delete")

  "Create or update a project (upsert)."
  upsertProject(project: ProjectInput!): Project!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@upsertProject"
    )

  "Create or update many projects (bulk upsert)."
  bulkUpsertProjects(projects: [ProjectInput!]!): [Project!]!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@bulkUpsertProjects"
    )

  # Location mutations
  "Create a new location."
  createLocation(location: LocationInput!): Location!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@create")

  "Update an existing location."
  updateLocation(id: ID!, location: LocationInput!): Location!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@update")

  "Delete a location."
  deleteLocation(id: ID!): Boolean!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@delete")

  "Create or update a location (upsert)."
  upsertLocation(location: LocationInput!): Location!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@upsertLocation"
    )

  # Audit mutations
  "Create a new audit plan."
  createAuditPlan(
    name: String! @rules(apply: ["required", "string", "max:255"])
    start_date: Date! @rules(apply: ["required", "date"])
    due_date: Date! @rules(apply: ["required", "date", "after:start_date"])
    description: String
    locations: [ID!]!
    auditors: [ID!]!
  ): AuditPlan!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\CreateAuditPlan")

  "Update an existing audit plan."
  updateAuditPlan(
    id: ID! @rules(apply: ["required", "exists:audit_plans,id"])
    name: String @rules(apply: ["string", "max:255"])
    start_date: Date @rules(apply: ["date"])
    due_date: Date @rules(apply: ["date"])
    status: String @rules(apply: ["in:Planning,In Progress,Completed,Overdue"])
    description: String
  ): AuditPlan!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UpdateAuditPlan")

  "Update audit asset status."
  updateAuditAsset(
    id: ID! @rules(apply: ["required", "exists:audit_assets,id"])
    current_status: String!
      @rules(
        apply: [
          "required"
          "in:欠落,返却済,廃止,保管(使用無),利用中,保管中,貸出中,故障中,利用予約,Pending,Found,In Storage,Broken,Missing,Scheduled for Disposal"
        ]
      )
    auditor_notes: String
    resolved: Boolean
    current_location: String
    current_user: String
  ): AuditAsset!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UpdateAuditAsset")

  "Complete an audit assignment."
  completeAuditAssignment(
    id: ID! @rules(apply: ["required", "exists:audit_assignments,id"])
    status: String!
      @rules(apply: ["required", "in:Assigned,In Progress,Completed"])
    notes: String
  ): AuditAssignment!
    @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UpdateAuditAssignment")

  # Corrective Action mutations
  "Create a new corrective action."
  createCorrectiveAction(action: CorrectiveActionInput!): CorrectiveAction!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@create"
    )

  "Update an existing corrective action."
  updateCorrectiveAction(
    id: ID! @rules(apply: ["required", "exists:corrective_actions,id"])
    action: CorrectiveActionInput!
  ): CorrectiveAction!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@update"
    )

  "Update the status of a corrective action."
  updateCorrectiveActionStatus(
    id: ID! @rules(apply: ["required", "exists:corrective_actions,id"])
    status: String!
      @rules(apply: ["required", "in:pending,in_progress,completed,overdue"])
    notes: String
  ): CorrectiveAction!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@updateStatus"
    )

  "Delete a corrective action."
  deleteCorrectiveAction(
    id: ID! @rules(apply: ["required", "exists:corrective_actions,id"])
  ): Boolean!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@delete"
    )

  # Corrective Action Assignment mutations
  "Assign a corrective action to an employee."
  assignCorrectiveAction(
    corrective_action_id: ID!
      @rules(apply: ["required", "exists:corrective_actions,id"])
    assigned_to_employee_id: ID!
      @rules(apply: ["required", "exists:employees,id"])
    notes: String
  ): CorrectiveActionAssignment!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionAssignmentMutations@assign"
    )

  "Update the status of a corrective action assignment."
  updateCorrectiveActionAssignmentStatus(
    id: ID!
      @rules(apply: ["required", "exists:corrective_action_assignments,id"])
    status: String!
      @rules(apply: ["required", "in:pending,in_progress,completed,overdue"])
    progress_notes: String
  ): CorrectiveActionAssignment!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionAssignmentMutations@updateStatus"
    )

  "Update the status of a corrective action for an employee."
  updateEmployeeCorrectiveActionStatus(
    action_id: ID! @rules(apply: ["required", "integer"])
    status: String!
      @rules(apply: ["required", "in:pending,in_progress,completed"])
    notes: String
    employee_id: ID! @rules(apply: ["required", "integer"])
  ): CorrectiveActionStatusResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeAuditMutations@updateCorrectiveActionStatus"
    )

  "Update asset status for an employee using access token."
  updateAssetStatus(
    token: String! @rules(apply: ["required"])
    assetId: ID! @rules(apply: ["required"])
    status: String!
      @rules(
        apply: [
          "required"
          "in:欠落,返却済,廃止,保管(使用無),利用中,保管中,貸出中,故障中,利用予約,Missing,Returned,Abolished,Stored - Not in Use,In Use,In Storage,On Loan,Broken,Reserved for Use"
        ]
      )
    notes: String
    reassignUserId: ID
  ): AssetStatusResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeAuditMutations@updateAssetStatus"
    )

  "Send scheduled reminders for pending and in-progress corrective actions."
  sendScheduledReminders: ScheduledRemindersResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeAuditMutations@sendScheduledReminders"
    )

  "Send manual reminders for specific corrective actions."
  sendManualReminders(
    actionIds: [ID!]! @rules(apply: ["required"])
  ): ManualRemindersResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeAuditMutations@sendManualReminders"
    )

  # Employee Audit mutations
  "Request access to an audit plan for an employee."
  requestAuditAccess(
    email: String! @rules(apply: ["required", "email"])
    audit_plan_id: String! @rules(apply: ["required", "string"])
  ): AuditAccessResponse!
    @field(
      resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeAuditMutations@requestAccess"
    )
}
