"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime
    @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

"A date string with format `Y-m-d`, e.g. `2018-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"Response type for Google Workspace user list query"
type GoogleWorkspaceUserResponse {
    "List of users from Google Workspace"
    users: [GoogleWorkspaceUser!]!

    "Token for getting the next page of results"
    nextPageToken: String

    "Total number of items in the current response"
    totalItems: Int!
}

"Represents a user in Google Workspace"
type GoogleWorkspaceUser {
    "Unique identifier for the user"
    id: ID!

    "Primary email address of the user"
    primaryEmail: String!

    "User's full name information"
    name: GoogleWorkspaceUserName!

    "Whether the user is a super admin"
    isAdmin: Boolean!

    "Whether the user is a delegated admin"
    isDelegatedAdmin: Boolean!

    "Last login time of the user"
    lastLoginTime: String

    "Creation time of the user account"
    creationTime: String!

    "Whether the user account is suspended"
    suspended: Boolean!

    "Whether the user must change password at next login"
    changePasswordAtNextLogin: Boolean!

    "Path of the organizational unit the user belongs to"
    orgUnitPath: String!
}

"Name information for a Google Workspace user"
type GoogleWorkspaceUserName {
    "Given (first) name"
    givenName: String!

    "Family (last) name"
    familyName: String!

    "Full name (givenName + familyName)"
    fullName: String!
}

"Indicates what fields are available at the top level of a query operation."
type Query {
    # Google Workspace queries
    "List users from Google Workspace"
    googleWorkspaceUsers(
        "Domain name (e.g., capo.co.jp)"
        domain: String!

        "Maximum number of results to return"
        maxResults: Int = 100

        "Token for getting the next page of results"
        pageToken: String

        "Search query to filter users"
        query: String

        "Organization unit path to filter users"
        orgUnitPath: String

        "Timestamp in RFC 3339 format to list users modified after this time"
        updatedMin: String
    ): GoogleWorkspaceUserResponse!
        @field(
            resolver: "Bu\\Gws\\GraphQL\\Queries\\GoogleWorkspaceQueries@listUsers"
        )

    # User queries
    "Find a single user by an identifying attribute."
    user(
        "Search by primary key."
        id: ID @eq @rules(apply: ["prohibits:email", "required_without:email"])

        "Search by email address."
        email: String
            @eq
            @rules(apply: ["prohibits:id", "required_without:id", "email"])
    ): User @find

    "List multiple users."
    users(
        "Filters by name. Accepts SQL LIKE wildcards `%` and `_`."
        name: String @where(operator: "like")
    ): [User!]! @paginate(defaultCount: 10)

    # Asset queries
    "Find a single asset by ID."
    asset(id: ID! @eq): Asset @find

    "List multiple assets with optional filtering."
    assets(
        "Exact match asset type (pc, monitor, smartphones, others)."
        type: String

        "Exclude asset types (for 'others' category)."
        exclude_types: [String!]

        "Filter by multiple statuses."
        statuses: [String!]

        "Filter by multiple locations."
        locations: [String!]

        "Filter by assigned user ID (employee id)."
        user_id: ID

        "Filter by employee name (partial match) via relation."
        employee_name: String

        "Field-specific filters (partial match)."
        asset_id: String
        hostname: String
        manufacturer: String
        model: String
        part_number: String
        serial_number: String
        form_factor: String
        os: String
        os_bit: String
        office_suite: String
        software_license_key: String
        wired_mac_address: String
        wired_ip_address: String
        wireless_mac_address: String
        wireless_ip_address: String
        previous_user: String
        project: String
        notes: String
        notes1: String
        notes2: String
        notes3: String
        notes4: String
        notes5: String
        cpu: String
        memory: String

        "Global search across common textual columns (partial match)."
        global: String

        "Pagination: page size and page number."
        first: Int
        page: Int

        "Sorting: database column name in snake_case and direction."
        sort_field: String
        sort_direction: String
    ): [Asset!]!
        @paginate(
            defaultCount: 100
            builder: "Bu\\Server\\GraphQL\\Queries\\AssetQueries@assetsBuilder"
        )

    # Employee queries
    "Find a single employee by ID."
    employee(id: ID! @eq): Employee @find

    "List multiple employees with optional filtering."
    employees(name: String @where(operator: "like")): [Employee!]!
        @paginate(defaultCount: 20)

    # Project queries
    "Find a single project by ID."
    project(id: ID! @eq): Project @find

    "List multiple projects with optional filtering."
    projects(name: String @where(operator: "like")): [Project!]!
        @paginate(defaultCount: 20)

    # Location queries
    "Find a single location by ID."
    location(id: ID! @eq): Location
        @field(
            resolver: "Bu\\Server\\GraphQL\\Queries\\LocationQueries@location"
        )

    "List multiple locations with optional filtering."
    locations(
        name: String @where(operator: "like")
        status: String @where(operator: "=")
        city: String @where(operator: "like")
    ): [Location!]!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Queries\\LocationQueries@locations"
        )

    # Audit queries
    "Find a single audit plan by ID."
    auditPlan(id: ID! @eq): AuditPlan @find

    "List multiple audit plans with optional filtering."
    auditPlans(
        status: String @where(operator: "=")
        created_by: ID @where(operator: "=")
    ): [AuditPlan!]! @paginate(defaultCount: 20)

    "Find audit assets for a specific audit plan."
    auditAssets(
        audit_plan_id: ID! @where(operator: "=")
        current_status: String @where(operator: "=")
    ): [AuditAsset!]! @paginate(defaultCount: 50)

    "Find audit assignments for a specific audit plan."
    auditAssignments(
        audit_plan_id: ID! @where(operator: "=")
        auditor_id: ID @where(operator: "=")
    ): [AuditAssignment!]! @paginate(defaultCount: 20)

    # Corrective Action queries
    "Find corrective actions for a specific audit plan."
    correctiveActions(
        audit_plan_id: ID @where(operator: "=")
        status: String @where(operator: "=")
        priority: String @where(operator: "=")
        assigned_to: String @where(operator: "like")
    ): [CorrectiveAction!]! @paginate(defaultCount: 50)

    "Find a single corrective action by ID."
    correctiveAction(id: ID! @eq): CorrectiveAction @find
}

"Account of a person who uses this application."
type User {
    "Unique primary key."
    id: ID!

    "Non-unique name."
    name: String!

    "Unique email address."
    email: String!

    "When the email was verified."
    email_verified_at: DateTime

    "When the account was created."
    created_at: DateTime!

    "When the account was last updated."
    updated_at: DateTime!
}

"Asset in the inventory system."
type Asset {
    "Unique primary key."
    id: ID!

    "Asset ID (PC001, PC002, etc.)."
    asset_id: String!

    "Type of asset (pc, monitor, phone)."
    type: String!

    "Hostname of the asset."
    hostname: String

    "Manufacturer of the asset."
    manufacturer: String

    "Model of the asset."
    model: String

    "Part number."
    part_number: String

    "Unique serial number."
    serial_number: String

    "Form factor (Laptop, Desktop, etc.)."
    form_factor: String

    "Operating system."
    os: String

    "OS bit version."
    os_bit: String

    "Office suite installed."
    office_suite: String

    "Software license key."
    software_license_key: String

    "Wired MAC address."
    wired_mac_address: String

    "Wired IP address."
    wired_ip_address: String

    "Wireless MAC address."
    wireless_mac_address: String

    "Wireless IP address."
    wireless_ip_address: String

    "Date when the asset was purchased."
    purchase_date: Date

    "Purchase price."
    purchase_price: Float

    "Purchase price including tax."
    purchase_price_tax_included: Float

    "Depreciation years."
    depreciation_years: Int

    "Depreciation department."
    depreciation_dept: String

    "CPU specification."
    cpu: String

    "Memory specification."
    memory: String

    "Location where the asset is stored."
    location: String

    "Current status of the asset."
    status: String

    "Previous user of the asset."
    previous_user: String

    "Current user assigned to this asset."
    user_id: ID

    "Employee assigned to this asset."
    employee: Employee
        @field(resolver: "Bu\\Server\\GraphQL\\Queries\\AssetQueries@employee")

    "Date when usage started."
    usage_start_date: Date

    "Date when usage ended."
    usage_end_date: Date

    "Carry in/out agreement status."
    carry_in_out_agreement: String

    "Last updated timestamp."
    last_updated: DateTime

    "Updated by user."
    updated_by: String

    "Additional notes about the asset."
    notes: String

    "Project associated with the asset."
    project: String

    "Additional notes fields."
    notes1: String
    notes2: String
    notes3: String
    notes4: String
    notes5: String

    "When the asset was created."
    created_at: DateTime!

    "When the asset was last updated."
    updated_at: DateTime!
}

"Employee in the system."
type Employee {
    "Unique primary key."
    id: ID!

    "Unique employee ID (from Google Workspace)."
    employee_id: String!

    "Full name of the employee."
    name: String!

    "Email address of the employee."
    email: String

    "Location/branch of the employee."
    location: String

    "Organizational unit path in Google Workspace."
    org_unit_path: String

    "Projects assigned to the employee."
    projects: [String!]

    "When the employee record was created."
    created_at: DateTime!

    "When the employee record was last updated."
    updated_at: DateTime!
}

"Location in the system."
type Location {
    "Unique primary key."
    id: ID!

    "Name of the location."
    name: String!

    "Address of the location."
    address: String

    "City of the location."
    city: String

    "State/province of the location."
    state: String

    "Country of the location."
    country: String

    "Postal code of the location."
    postal_code: String

    "Phone number of the location."
    phone: String

    "Email of the location."
    email: String

    "Manager of the location."
    manager: String

    "Status of the location."
    status: String

    "Whether the location is visible."
    visible: Boolean!

    "Order of the location for display."
    order: Int!

    "When the location was created."
    created_at: DateTime!

    "When the location was last updated."
    updated_at: DateTime!
}

"Project in the system."
type Project {
    "Unique primary key."
    id: ID!

    "Name of the project."
    name: String!

    "Description of the project."
    description: String

    "Whether the project is visible."
    visible: Boolean!

    "Order of the project for sorting."
    order: Int!

    "When the project was created."
    created_at: DateTime!

    "When the project was last updated."
    updated_at: DateTime!
}

"Input for creating or updating an asset. Uses the same snake_case field names as the Asset type."
input AssetInput {
    asset_id: String!
    type: String
    hostname: String
    manufacturer: String
    model: String
    part_number: String
    serial_number: String
    form_factor: String
    os: String
    os_bit: String
    office_suite: String
    software_license_key: String
    wired_mac_address: String
    wired_ip_address: String
    wireless_mac_address: String
    wireless_ip_address: String
    purchase_date: Date
    purchase_price: Float
    purchase_price_tax_included: Float
    depreciation_years: Int
    depreciation_dept: String
    cpu: String
    memory: String
    location: String
    status: String
    previous_user: String
    user: String
    user_id: ID
    usage_start_date: Date
    usage_end_date: Date
    carry_in_out_agreement: String
    last_updated: DateTime
    updated_by: String
    notes: String
    project: String
    notes1: String
    notes2: String
    notes3: String
    notes4: String
    notes5: String
}

"Input for creating or updating an employee."
input EmployeeInput {
    employee_id: String!
    name: String!
    email: String
    location: String
    projects: [String!]
}

"Input for creating or updating a project."
input ProjectInput {
    name: String!
    description: String
    visible: Boolean
    order: Int
}

"Input for creating or updating a location."
input LocationInput {
    name: String!
    address: String
    city: String
    state: String
    country: String
    postal_code: String
    phone: String
    email: String
    manager: String
    status: String
    visible: Boolean
    order: Int
}

"Input for creating or updating a user."
input UserInput {
    name: String!
    email: String! @rules(apply: ["email"])
    password: String
}

"Audit plan in the system."
type AuditPlan {
    "Unique primary key."
    id: ID!

    "Name of the audit plan."
    name: String!

    "Start date of the audit."
    start_date: Date!

    "Due date for completing the audit."
    due_date: Date!

    "Current status of the audit plan."
    status: String!

    "User who created the audit plan."
    created_by: ID!

    "Description of the audit plan."
    description: String

    "When the audit plan was created."
    created_at: DateTime!

    "When the audit plan was last updated."
    updated_at: DateTime!

    "Audit assignments for this plan."
    assignments: [AuditAssignment!]! @hasMany

    "Assets being audited in this plan."
    auditAssets: [AuditAsset!]! @hasMany

    "Progress percentage of the audit plan."
    progress: Int! @method

    "Whether the audit plan is overdue."
    is_overdue: Boolean! @method
}

"Audit assignment linking auditors to locations."
type AuditAssignment {
    "Unique primary key."
    id: ID!

    "Audit plan this assignment belongs to."
    audit_plan_id: ID!

    "Location assigned for this audit."
    location_id: ID!

    "Auditor assigned to this location."
    auditor_id: ID!

    "Status of the assignment."
    status: String!

    "Notes about the assignment."
    notes: String

    "When the assignment was made."
    assigned_at: DateTime!

    "When the assignment was created."
    created_at: DateTime!

    "When the assignment was last updated."
    updated_at: DateTime!

    "The audit plan for this assignment."
    audit_plan: AuditPlan! @belongsTo

    "The location for this assignment."
    location: Location! @belongsTo

    "The auditor for this assignment."
    auditor: Employee! @belongsTo
}

"Audit asset tracking individual assets in an audit."
type AuditAsset {
    "Unique primary key."
    id: ID!

    "Audit plan this asset belongs to."
    audit_plan_id: ID!

    "Asset being audited."
    asset_id: ID!

    "Original location when audit plan was created."
    original_location: String!

    "Original user when audit plan was created."
    original_user: String

    "Current status of the asset audit."
    current_status: String!

    "Notes from the auditor."
    auditor_notes: String

    "When the asset was audited."
    audited_at: DateTime

    "Whether issues were resolved."
    resolved: Boolean!

    "Whether the asset has been audited (audit progress tracking)."
    audit_status: Boolean!

    "Who audited this asset."
    audited_by: String

    "Current location if different from original."
    current_location: String

    "Current user if different from original."
    current_user: String

    "When the audit asset record was created."
    created_at: DateTime!

    "When the audit asset record was last updated."
    updated_at: DateTime!

    "The audit plan for this asset."
    audit_plan: AuditPlan! @belongsTo

    "The asset being audited."
    asset: Asset! @belongsTo

    "Whether the asset has been audited."
    is_audited: Boolean! @method

    "Whether the asset has issues."
    has_issues: Boolean! @method

    "Corrective actions for this audit asset."
    correctiveActions: [CorrectiveAction!]! @hasMany
}

"Corrective action to resolve audit findings."
type CorrectiveAction {
    "Unique primary key."
    id: ID!

    "Audit asset this action relates to."
    audit_asset_id: ID!

    "Audit plan this action belongs to."
    audit_plan_id: ID!

    "Description of the issue found."
    issue: String!

    "Action required to resolve the issue."
    action: String!

    "Person assigned to complete this action."
    assigned_to: String

    "Priority level of the action."
    priority: String!

    "Current status of the action."
    status: String!

    "Due date for completion."
    due_date: Date!

    "Date when action was completed."
    completed_date: Date

    "Additional notes about the action."
    notes: String

    "When the action was created."
    created_at: DateTime!

    "When the action was last updated."
    updated_at: DateTime!

    "The audit asset this action relates to."
    auditAsset: AuditAsset! @belongsTo

    "The audit plan this action belongs to."
    auditPlan: AuditPlan! @belongsTo

    "The assignment for this corrective action."
    assignment: CorrectiveActionAssignment @hasOne
}

"Assignment of a corrective action to an audit assignment."
type CorrectiveActionAssignment {
    "Unique primary key."
    id: ID!

    "Corrective action this assignment belongs to."
    corrective_action_id: ID!

    "Audit assignment this corrective action is linked to."
    audit_assignment_id: ID!

    "Employee assigned to complete this corrective action."
    assigned_to_employee_id: ID

    "Current status of the assignment."
    status: String!

    "When the assignment was made."
    assigned_at: DateTime!

    "When the assignment was started."
    started_at: DateTime

    "When the assignment was completed."
    completed_at: DateTime

    "Progress notes for this assignment."
    progress_notes: String

    "When the assignment was created."
    created_at: DateTime!

    "When the assignment was last updated."
    updated_at: DateTime!

    "The corrective action for this assignment."
    correctiveAction: CorrectiveAction! @belongsTo

    "The audit assignment this corrective action is linked to."
    auditAssignment: AuditAssignment! @belongsTo

    "The employee assigned to complete this corrective action."
    assignedToEmployee: Employee @belongsTo
}

"Input for creating or updating a corrective action."
input CorrectiveActionInput {
    "Audit asset ID this action relates to."
    audit_asset_id: ID!

    "Description of the issue found."
    issue: String!

    "Action required to resolve the issue."
    action: String!

    "Person assigned to complete this action."
    assigned_to: String

    "Priority level of the action."
    priority: String!

    "Due date for completion."
    due_date: Date!

    "Additional notes about the action."
    notes: String
}

"Indicates what fields are available at the top level of a mutation operation."
type Mutation {
    # User mutations
    "Create a new user."
    createUser(user: UserInput!): User!
        @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UserMutations@create")

    "Update an existing user."
    updateUser(id: ID!, user: UserInput!): User!
        @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UserMutations@update")

    "Delete a user."
    deleteUser(id: ID!): Boolean!
        @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UserMutations@delete")

    # Asset mutations
    "Create or update a single asset by asset_id."
    upsertAsset(asset: AssetInput!): Asset
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\AssetMutations@upsertAsset"
        )

    "Create or update many assets by asset_id. Returns the upserted assets."
    bulkUpsertAssets(assets: [AssetInput!]!): [Asset!]!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\AssetMutations@bulkUpsertAssets"
        )

    "Delete an asset by asset_id. Returns true if deleted or did not exist."
    deleteAsset(asset_id: String!): Boolean!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\AssetMutations@deleteAsset"
        )

    # Employee mutations
    "Create a new employee."
    createEmployee(employee: EmployeeInput!): Employee!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@create"
        )

    "Update an existing employee."
    updateEmployee(id: ID!, employee: EmployeeInput!): Employee!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@update"
        )

    "Delete an employee."
    deleteEmployee(id: ID!): Boolean!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@delete"
        )

    "Create or update an employee (upsert)."
    upsertEmployee(employee: EmployeeInput!): Employee!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@upsertEmployee"
        )

    "Create or update many employees (bulk upsert)."
    bulkUpsertEmployees(employees: [EmployeeInput!]!): [Employee!]!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\EmployeeMutations@bulkUpsertEmployees"
        )

    # Project mutations
    "Create a new project."
    createProject(project: ProjectInput!): Project!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@create"
        )

    "Update an existing project."
    updateProject(id: ID!, project: ProjectInput!): Project!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@update"
        )

    "Delete a project."
    deleteProject(id: ID!): Boolean!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@delete"
        )

    "Create or update a project (upsert)."
    upsertProject(project: ProjectInput!): Project!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@upsertProject"
        )

    "Create or update many projects (bulk upsert)."
    bulkUpsertProjects(projects: [ProjectInput!]!): [Project!]!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\ProjectMutations@bulkUpsertProjects"
        )

    # Location mutations
    "Create a new location."
    createLocation(location: LocationInput!): Location!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@create"
        )

    "Update an existing location."
    updateLocation(id: ID!, location: LocationInput!): Location!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@update"
        )

    "Delete a location."
    deleteLocation(id: ID!): Boolean!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@delete"
        )

    "Create or update a location (upsert)."
    upsertLocation(location: LocationInput!): Location!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\LocationMutations@upsertLocation"
        )

    # Audit mutations
    "Create a new audit plan."
    createAuditPlan(
        name: String! @rules(apply: ["required", "string", "max:255"])
        start_date: Date! @rules(apply: ["required", "date"])
        due_date: Date! @rules(apply: ["required", "date", "after:start_date"])
        description: String
        locations: [ID!]!
        auditors: [ID!]!
    ): AuditPlan!
        @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\CreateAuditPlan")

    "Update an existing audit plan."
    updateAuditPlan(
        id: ID! @rules(apply: ["required", "exists:audit_plans,id"])
        name: String @rules(apply: ["string", "max:255"])
        start_date: Date @rules(apply: ["date"])
        due_date: Date @rules(apply: ["date"])
        status: String
            @rules(apply: ["in:Planning,In Progress,Completed,Overdue"])
        description: String
    ): AuditPlan!
        @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UpdateAuditPlan")

    "Update audit asset status."
    updateAuditAsset(
        id: ID! @rules(apply: ["required", "exists:audit_assets,id"])
        current_status: String!
            @rules(
                apply: [
                    "required"
                    "in:欠落,返却済,廃止,保管(使用無),利用中,保管中,貸出中,故障中,利用予約,Pending,Found,In Storage,Broken,Missing,Scheduled for Disposal"
                ]
            )
        auditor_notes: String
        resolved: Boolean
        current_location: String
        current_user: String
    ): AuditAsset!
        @field(resolver: "Bu\\Server\\GraphQL\\Mutations\\UpdateAuditAsset")

    "Complete an audit assignment."
    completeAuditAssignment(
        id: ID! @rules(apply: ["required", "exists:audit_assignments,id"])
        status: String!
            @rules(apply: ["required", "in:Assigned,In Progress,Completed"])
        notes: String
    ): AuditAssignment!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\UpdateAuditAssignment"
        )

    # Corrective Action mutations
    "Create a new corrective action."
    createCorrectiveAction(action: CorrectiveActionInput!): CorrectiveAction!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@create"
        )

    "Update an existing corrective action."
    updateCorrectiveAction(
        id: ID! @rules(apply: ["required", "exists:corrective_actions,id"])
        action: CorrectiveActionInput!
    ): CorrectiveAction!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@update"
        )

    "Update the status of a corrective action."
    updateCorrectiveActionStatus(
        id: ID! @rules(apply: ["required", "exists:corrective_actions,id"])
        status: String!
            @rules(
                apply: ["required", "in:pending,in_progress,completed,overdue"]
            )
        notes: String
    ): CorrectiveAction!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@updateStatus"
        )

    "Delete a corrective action."
    deleteCorrectiveAction(
        id: ID! @rules(apply: ["required", "exists:corrective_actions,id"])
    ): Boolean!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionMutations@delete"
        )

    # Corrective Action Assignment mutations
    "Assign a corrective action to an employee."
    assignCorrectiveAction(
        corrective_action_id: ID!
            @rules(apply: ["required", "exists:corrective_actions,id"])
        assigned_to_employee_id: ID!
            @rules(apply: ["required", "exists:employees,id"])
        notes: String
    ): CorrectiveActionAssignment!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionAssignmentMutations@assign"
        )

    "Update the status of a corrective action assignment."
    updateCorrectiveActionAssignmentStatus(
        id: ID!
            @rules(
                apply: ["required", "exists:corrective_action_assignments,id"]
            )
        status: String!
            @rules(
                apply: ["required", "in:pending,in_progress,completed,overdue"]
            )
        progress_notes: String
    ): CorrectiveActionAssignment!
        @field(
            resolver: "Bu\\Server\\GraphQL\\Mutations\\CorrectiveActionAssignmentMutations@updateStatus"
        )
}
